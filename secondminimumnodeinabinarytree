#include"stdafx.h"
#include<iostream>
#include<algorithm>
/*
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。

给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。

示例 1:

输入:
2
/ \
2   5
/ \
5   7

输出: 5
说明: 最小的值是 2 ，第二小的值是 5 。
*/
using namespace std;
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) :val(x), left(NULL), right(NULL) {

	}
};
class Solution {
public:
	int findSecondMinimumValue(TreeNode *root) {
		if (!root->left||!root) {
			return -1;
		}
		int left = root->val == root->left->val ? findSecondMinimumValue(root->left) : root->left->val;
		int right = root->val == root->right->val ? findSecondMinimumValue(root->right):root->right->val;
		if (left == -1) {
			return right;
		}
		if (right == -1) {
			return left;
		}
		return min(left, right);

	}
};
